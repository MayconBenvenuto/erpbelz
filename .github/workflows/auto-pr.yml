name: Auto PR (testes -> dev -> main)

on:
  push:
    branches:
      - testes
  workflow_dispatch:
    inputs:
      force_merge_dev_main:
        description: "Forçar tentativa de merge dev->main (ignora label needs-full-qa se true)"
        required: false
        default: "false"

concurrency:
  group: "auto-pr-${{ github.ref }}"
  # Mantemos cancel-in-progress para evitar múltiplos pushes em testes competindo.
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

jobs:
  create-prs-and-test:
    name: Criar/Mesclar PR testes->dev, rodar testes e promover dev->main
    runs-on: ubuntu-latest
    steps:
      - name: Verificar / criar PR testes -> dev
        id: pr_testes_dev
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'testes';
            const base = 'dev';

            async function getExistingPR(attempts = 5) {
              for (let i=1;i<=attempts;i++) {
                try {
                  const { data } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}`, base, per_page: 5 });
                  return data[0];
                } catch (e) {
                  const retriable = !e.status || e.status >= 500;
                  core.warning(`Falha listando PR (tentativa ${i}): ${e.message}`);
                  if (!retriable || i === attempts) throw e;
                  await new Promise(r=>setTimeout(r, 1000 * i));
                }
              }
            }

            let existing = await getExistingPR();
            if (!existing) {
              core.notice('Nenhum PR existente testes->dev. Criando...');
              const created = await github.rest.pulls.create({ owner, repo, head, base, title: `Sync ${head} -> ${base}`, body: 'PR automático gerado pelo workflow ao receber push em testes.' });
              existing = created.data;
              core.notice(`PR criado #${existing.number}`);
            } else {
              core.notice(`PR já existente #${existing.number}`);
            }
            core.setOutput('pr_number', existing.number);

      - name: Checkout código (branch testes)
        uses: actions/checkout@v4
        with:
          ref: testes

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'yarn'

      - name: Remover package-lock (padronizar yarn)
        run: |
          if [ -f package-lock.json ]; then rm package-lock.json; fi

      - name: Instalar dependências (yarn)
        run: yarn install --frozen-lockfile

      - name: Rodar testes
        run: yarn test --reporter=dot

      - name: Tentativa de auto-resolução de conflitos básicos (dev -> testes)
        id: auto_resolve_conflicts
        run: |
          set -e
          echo "Verificando PR aberto testes->dev para detectar estado dirty..."
          PR_JSON=$(gh api repos/${{ github.repository }}/pulls --paginate -q '.[] | select(.head.ref=="testes" and .base.ref=="dev")' || true)
          if [ -z "$PR_JSON" ]; then
            echo "Nenhum PR testes->dev encontrado."
            exit 0
          fi
          NUMBER=$(echo "$PR_JSON" | jq -r '.number')
          MERGEABLE_STATE=$(gh api repos/${{ github.repository }}/pulls/$NUMBER -q .mergeable_state || echo unknown)
          echo "Estado atual: $MERGEABLE_STATE"
          if [ "$MERGEABLE_STATE" != "dirty" ]; then
            echo "Sem conflitos sujos a auto-resolver."
            exit 0
          fi
          echo "Conflitos detectados. Tentando merge de dev em testes mantendo versão de testes para arquivos de alto churn..."
          git fetch origin dev --depth=1
          # Estamos já em testes (checkout inicial). Faz merge sem commit para capturar conflitos.
          if git merge origin/dev --no-commit --no-ff; then
            echo "Merge limpo inesperadamente (mergeable_state estava dirty). Prosseguindo com commit."
            git commit -m "chore: merge dev into testes (auto-resolução)"
            git push origin HEAD:testes
            exit 0
          fi
          echo "Listando arquivos em conflito..."
          CONFLICTS=$(git diff --name-only --diff-filter=U || true)
          echo "$CONFLICTS" | sed 's/^/ - /'
          # Arquivos para preferir versão de testes (ours):
          KEEP_OURS_PATTERNS="app/page.js app/sections/Movimentacao.jsx app/components/CommandPalette.jsx"
          SUCCESS=1
          for f in $CONFLICTS; do
            if echo "$KEEP_OURS_PATTERNS" | grep -qw "$f"; then
              echo "Mantendo versão de testes (ours) para $f"
              git checkout --ours -- "$f" || SUCCESS=0
            else
              # fallback: manter versão da base dev para arquivos lock ou configs específicos
              if echo "$f" | grep -Eq 'package-lock.json|yarn.lock'; then
                echo "Mantendo versão de dev (theirs) para $f"
                git checkout --theirs -- "$f" || SUCCESS=0
              else
                echo "Arquivo $f não está na lista de auto-resolução. Abortando tentativa."
                SUCCESS=0
              fi
            fi
          done
          if [ $SUCCESS -eq 1 ]; then
            git add .
            if git diff --cached --quiet; then
              echo "Nada para commitar após resolução."
            else
              git commit -m "chore: auto-resolve conflitos básicos dev->testes"
              git push origin HEAD:testes
              echo "Auto-resolução concluída e push realizado."
            fi
          else
            echo "Nem todos conflitos foram resolvidos automaticamente. Fazendo abort do merge."
            git merge --abort || true
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_NO_UPDATE_NOTIFIER: 1
          GH_PROMPT_DISABLED: 1

      - name: Merge automático PR testes->dev (fast-forward/squash resiliente)
        id: merge_testes_dev
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const base = 'dev';
            const head = 'testes';

            async function findPR() {
              for (let attempt=1; attempt<=5; attempt++) {
                try {
                  const { data } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}`, base, per_page: 5 });
                  return data[0];
                } catch (e) {
                  const retriable = !e.status || e.status >= 500;
                  core.warning(`Erro listando PR testes->dev tentativa ${attempt}: ${e.message}`);
                  if (!retriable || attempt===5) throw e;
                  await new Promise(r=>setTimeout(r, 1200 * attempt));
                }
              }
            }

            const pr = await findPR();
            if (!pr) { core.notice('Nenhum PR testes->dev aberto para merge.'); core.setOutput('merged','false'); return; }

            async function waitMergeable(pull_number, attempts = 10, delayMs = 3000) {
              for (let i=0;i<attempts;i++) {
                const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (data.mergeable !== null) {
                  core.notice(`mergeable_state tentativa ${i+1}: ${data.mergeable_state}`);
                  return data;
                }
                core.info(`mergeable null (tentativa ${i+1}) aguardando ${delayMs}ms`);
                await new Promise(r=>setTimeout(r, delayMs));
              }
              throw new Error('Timeout aguardando estado mergeable != null');
            }

            let details = await waitMergeable(pr.number);

            if (details.mergeable_state === 'behind') {
              core.notice('PR atrás de dev — tentando updateBranch...');
              try {
                await github.rest.pulls.updateBranch({ owner, repo, pull_number: pr.number });
                details = await waitMergeable(pr.number);
              } catch (e) {
                core.warning(`Falha updateBranch: ${e.message}`);
              }
            }

            const blocked = ['dirty','blocked','draft','unknown'];
            if (blocked.includes(details.mergeable_state)) {
              core.notice(`PR não mesclável agora (estado ${details.mergeable_state}).`);
              core.setOutput('merged','false');
              return;
            }
            if (details.mergeable_state === 'behind') {
              core.notice('Ainda behind após updateBranch — evitando merge automático.');
              core.setOutput('merged','false');
              return;
            }

            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
              core.notice(`PR #${pr.number} mesclado (squash).`);
              core.setOutput('merged','true');
            } catch (e) {
              core.setFailed(`Falha ao mesclar PR testes->dev: ${e.message}`);
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Atualizar branch dev local pós-merge
        if: success() && steps.merge_testes_dev.outputs.merged == 'true'
        run: |
          git fetch origin dev --depth=1
          git checkout dev
          git pull --ff-only origin dev
      - name: Criar PR dev -> main (se merge e testes passaram)
        if: success() && steps.merge_testes_dev.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'dev';
            const base = 'main';
            try { await github.rest.repos.getBranch({ owner, repo, branch: head }); } catch { core.setFailed(`Branch ${head} não existe`); return; }
            try { await github.rest.repos.getBranch({ owner, repo, branch: base }); } catch { core.setFailed(`Branch ${base} não existe`); return; }
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', base });
            const exists = prs.find(p => p.head.ref === head && p.base.ref === base);
            if (exists) { core.notice(`PR dev->main já existe (#${exists.number})`); return; }
            const created = await github.rest.pulls.create({ owner, repo, head, base, title: `Promover ${head} -> ${base}`, body: 'PR automático criado após sucesso nos testes e merge testes->dev. Não será mesclado automaticamente caso verificações falhem.' });
            // Adiciona label para indicar necessidade de verificação completa
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: created.data.number, labels: ['needs-full-qa'] });
            } catch (e) { core.warning('Falha ao adicionar label: ' + e.message); }
            core.notice(`PR dev->main criado #${created.data.number}`);

      - name: Merge automático dev->main (quando aprovado)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const base = 'main';
            const head = 'dev';
            const force = (core.getInput('force_merge_dev_main') || 'false').toLowerCase() === 'true';

            async function findPR() {
              for (let attempt=1; attempt<=5; attempt++) {
                try {
                  const { data } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}`, base, per_page: 5 });
                  return data[0];
                } catch (e) {
                  const retriable = !e.status || e.status >= 500;
                  core.warning(`Erro listando PR dev->main tentativa ${attempt}: ${e.message}`);
                  if (!retriable || attempt===5) throw e;
                  await new Promise(r=>setTimeout(r, 1200 * attempt));
                }
              }
            }

            const pr = await findPR();
            if (!pr) { core.notice('Nenhum PR dev->main aberto para merge automático.'); return; }

            const labels = (pr.labels || []).map(l=>l.name);
            if (labels.includes('needs-full-qa') && !force) {
              core.notice('Label needs-full-qa presente. Aguardando aprovação (ou usar workflow_dispatch force_merge_dev_main=true).');
              return;
            }
            try {
              const combined = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: pr.head.sha });
              if (combined.state && combined.state !== 'success') {
                core.notice(`Status combinado ainda não é success (${combined.state}). Merge adiado.`);
                return;
              }
            } catch (e) {
              core.warning(`Falha obtendo combined status: ${e.message}`);
            }

            async function waitMergeable(pull_number, attempts = 10, delayMs = 3000) {
              for (let i=0;i<attempts;i++) {
                const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (data.mergeable !== null) {
                  core.notice(`mergeable_state dev->main tentativa ${i+1}: ${data.mergeable_state}`);
                  return data;
                }
                core.info(`mergeable null (dev->main) tentativa ${i+1}; aguardando ${delayMs}ms`);
                await new Promise(r=>setTimeout(r, delayMs));
              }
              throw new Error('Timeout aguardando estado mergeable != null (dev->main)');
            }

            let details = await waitMergeable(pr.number);
            if (details.mergeable_state === 'behind') {
              try {
                await github.rest.pulls.updateBranch({ owner, repo, pull_number: pr.number });
                details = await waitMergeable(pr.number);
              } catch (e) {
                core.warning(`Falha updateBranch dev->main: ${e.message}`);
              }
            }
            const blocked = ['dirty','blocked','draft','unknown'];
            if (blocked.includes(details.mergeable_state)) { core.notice(`PR dev->main não mesclável (estado ${details.mergeable_state}).`); return; }
            if (details.mergeable_state === 'behind') { core.notice('Ainda behind dev->main após updateBranch. Abortando.'); return; }

            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
              core.notice(`PR dev->main #${pr.number} mesclado (squash) automaticamente.`);
            } catch (e) { core.setFailed(`Falha ao mesclar dev->main: ${e.message}`); }

      - name: Resultado final
        if: always()
        run: |
          echo "Status final do job: ${{ job.status }}"
