name: Auto PR (testes -> dev -> main)

on:
  push:
    branches:
      - testes

concurrency:
  group: "auto-pr-${{ github.ref }}"
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

jobs:
  create-prs-and-test:
    name: Criar/Mesclar PR testes->dev, rodar testes e promover dev->main
    runs-on: ubuntu-latest
    steps:
      - name: Verificar / criar PR testes -> dev
        id: pr_testes_dev
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'testes';
            const base = 'dev';
            // Listar PRs abertos com head testes e base dev
            const prs = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', base
            });
            let existing = prs.find(p => p.head.ref === head && p.base.ref === base);
            if (!existing) {
              const created = await github.rest.pulls.create({ owner, repo, head, base, title: `Sync ${head} -> ${base}`, body: 'PR automático gerado pelo workflow ao receber push em testes.' });
              existing = created.data;
              core.notice(`PR criado #${existing.number}`);
            } else {
              core.notice(`PR já existente #${existing.number}`);
            }
            core.setOutput('pr_number', existing.number);

      - name: Checkout código (branch testes)
        uses: actions/checkout@v4
        with:
          ref: testes

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'yarn'

      - name: Remover package-lock (padronizar yarn)
        run: |
          if [ -f package-lock.json ]; then rm package-lock.json; fi

      - name: Instalar dependências (yarn)
        run: yarn install --frozen-lockfile

      - name: Rodar testes
        run: yarn test --reporter=dot

      - name: Tentativa de auto-resolução de conflitos básicos (dev -> testes)
        id: auto_resolve_conflicts
        run: |
          set -e
          echo "Verificando PR aberto testes->dev para detectar estado dirty..."
          PR_JSON=$(gh api repos/${{ github.repository }}/pulls --paginate -q '.[] | select(.head.ref=="testes" and .base.ref=="dev")' || true)
          if [ -z "$PR_JSON" ]; then
            echo "Nenhum PR testes->dev encontrado."
            exit 0
          fi
          NUMBER=$(echo "$PR_JSON" | jq -r '.number')
          MERGEABLE_STATE=$(gh api repos/${{ github.repository }}/pulls/$NUMBER -q .mergeable_state || echo unknown)
          echo "Estado atual: $MERGEABLE_STATE"
          if [ "$MERGEABLE_STATE" != "dirty" ]; then
            echo "Sem conflitos sujos a auto-resolver."
            exit 0
          fi
          echo "Conflitos detectados. Tentando merge de dev em testes mantendo versão de testes para arquivos de alto churn..."
          git fetch origin dev --depth=1
          # Estamos já em testes (checkout inicial). Faz merge sem commit para capturar conflitos.
          if git merge origin/dev --no-commit --no-ff; then
            echo "Merge limpo inesperadamente (mergeable_state estava dirty). Prosseguindo com commit."
            git commit -m "chore: merge dev into testes (auto-resolução)"
            git push origin HEAD:testes
            exit 0
          fi
          echo "Listando arquivos em conflito..."
          CONFLICTS=$(git diff --name-only --diff-filter=U || true)
          echo "$CONFLICTS" | sed 's/^/ - /'
          # Arquivos para preferir versão de testes (ours):
          KEEP_OURS_PATTERNS="app/page.js app/sections/Movimentacao.jsx app/components/CommandPalette.jsx"
          SUCCESS=1
          for f in $CONFLICTS; do
            if echo "$KEEP_OURS_PATTERNS" | grep -qw "$f"; then
              echo "Mantendo versão de testes (ours) para $f"
              git checkout --ours -- "$f" || SUCCESS=0
            else
              # fallback: manter versão da base dev para arquivos lock ou configs específicos
              if echo "$f" | grep -Eq 'package-lock.json|yarn.lock'; then
                echo "Mantendo versão de dev (theirs) para $f"
                git checkout --theirs -- "$f" || SUCCESS=0
              else
                echo "Arquivo $f não está na lista de auto-resolução. Abortando tentativa."
                SUCCESS=0
              fi
            fi
          done
          if [ $SUCCESS -eq 1 ]; then
            git add .
            if git diff --cached --quiet; then
              echo "Nada para commitar após resolução."
            else
              git commit -m "chore: auto-resolve conflitos básicos dev->testes"
              git push origin HEAD:testes
              echo "Auto-resolução concluída e push realizado."
            fi
          else
            echo "Nem todos conflitos foram resolvidos automaticamente. Fazendo abort do merge."
            git merge --abort || true
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_NO_UPDATE_NOTIFIER: 1
          GH_PROMPT_DISABLED: 1

      - name: Merge automático PR testes->dev (fast-forward/squash)
        id: merge_testes_dev
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const base = 'dev';
            const head = 'testes';
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', base });
            const pr = prs.find(p => p.head.ref === head && p.base.ref === base);
            if (!pr) { core.notice('Nenhum PR testes->dev aberto para merge.'); return; }
            // Aguarda campo mergeable ser calculado (pode vir null inicialmente)
            async function waitMergeable(pull_number, attempts = 8, delayMs = 4000) {
              for (let i = 0; i < attempts; i++) {
                const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (data.mergeable !== null) return data;
                await new Promise(r => setTimeout(r, delayMs));
              }
              throw new Error('Timeout aguardando estado mergeable != null');
            }

            let details = await waitMergeable(pr.number);
            core.notice(`mergeable_state inicial: ${details.mergeable_state}`);

            // Se branch está atrás da base, tenta atualizar
            if (details.mergeable_state === 'behind') {
              try {
                await github.rest.pulls.updateBranch({ owner, repo, pull_number: pr.number });
                core.notice('Branch do PR atualizada com dev. Revalidando mergeability...');
                details = await waitMergeable(pr.number);
                core.notice(`Novo mergeable_state: ${details.mergeable_state}`);
              } catch (e) {
                core.warning('Falha ao atualizar branch (talvez proteção bloqueando): ' + e.message);
              }
            }

            const blockedStates = ['dirty','blocked','draft','unknown'];
            if (blockedStates.includes(details.mergeable_state)) {
              core.notice(`PR não mesclável automaticamente agora (estado ${details.mergeable_state}). Merge manual ou ajuste necessário.`);
              core.setOutput('merged','false');
              return;
            }

            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
              core.notice(`PR #${pr.number} mesclado (squash).`);
              core.setOutput('merged','true');
            } catch (e) {
              core.setFailed(`Falha ao mesclar PR testes->dev após validações: ${e.message}`);
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Atualizar branch dev local pós-merge
        if: success() && steps.merge_testes_dev.outputs.merged == 'true'
        run: |
          git fetch origin dev --depth=1
          git checkout dev
          git pull --ff-only origin dev
      - name: Criar PR dev -> main (se merge e testes passaram)
        if: success() && steps.merge_testes_dev.outputs.merged == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'dev';
            const base = 'main';
            try { await github.rest.repos.getBranch({ owner, repo, branch: head }); } catch { core.setFailed(`Branch ${head} não existe`); return; }
            try { await github.rest.repos.getBranch({ owner, repo, branch: base }); } catch { core.setFailed(`Branch ${base} não existe`); return; }
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', base });
            const exists = prs.find(p => p.head.ref === head && p.base.ref === base);
            if (exists) { core.notice(`PR dev->main já existe (#${exists.number})`); return; }
            const created = await github.rest.pulls.create({ owner, repo, head, base, title: `Promover ${head} -> ${base}`, body: 'PR automático criado após sucesso nos testes e merge testes->dev. Não será mesclado automaticamente caso verificações falhem.' });
            // Adiciona label para indicar necessidade de verificação completa
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: created.data.number, labels: ['needs-full-qa'] });
            } catch (e) { core.warning('Falha ao adicionar label: ' + e.message); }
            core.notice(`PR dev->main criado #${created.data.number}`);

      - name: Merge automático dev->main (quando aprovado)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const base = 'main';
            const head = 'dev';
            // Localiza PR aberto dev->main
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', base });
            const pr = prs.find(p => p.head.ref === head && p.base.ref === base);
            if (!pr) { core.notice('Nenhum PR dev->main aberto para merge automático.'); return; }
            // Verifica labels bloqueadoras
            const labels = (pr.labels || []).map(l => l.name);
            if (labels.includes('needs-full-qa')) { core.notice('Label needs-full-qa presente. Aguardando aprovação.'); return; }
            // Verifica status combinado (caso existam checks)
            try {
              const combined = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: pr.head.sha });
              if (combined.state && combined.state !== 'success') {
                core.notice(`Status combinado ainda não é success (${combined.state}). Merge adiado.`);
                return;
              }
            } catch (e) {
              core.warning('Não foi possível obter status combinado: ' + e.message + ' (prosseguindo se demais condições ok)');
            }
            // Função waitMergeable reutilizável
            async function waitMergeable(pull_number, attempts = 8, delayMs = 4000) {
              for (let i = 0; i < attempts; i++) {
                const { data } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (data.mergeable !== null) return data;
                await new Promise(r => setTimeout(r, delayMs));
              }
              throw new Error('Timeout aguardando estado mergeable != null');
            }
            let details = await waitMergeable(pr.number);
            core.notice(`mergeable_state dev->main inicial: ${details.mergeable_state}`);
            if (details.mergeable_state === 'behind') {
              try {
                await github.rest.pulls.updateBranch({ owner, repo, pull_number: pr.number });
                core.notice('Branch dev atualizada com main (updateBranch). Revalidando...');
                details = await waitMergeable(pr.number);
              } catch (e) { core.warning('Falha ao atualizar branch dev->main: ' + e.message); }
            }
            const blocked = ['dirty','blocked','draft','unknown'];
            if (blocked.includes(details.mergeable_state)) { core.notice(`PR dev->main não mesclável agora (estado ${details.mergeable_state}).`); return; }
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
              core.notice(`PR dev->main #${pr.number} mesclado (squash) automaticamente.`);
            } catch (e) { core.setFailed('Falha ao mesclar dev->main: ' + e.message); }

      - name: Resultado final
        if: always()
        run: |
          echo "Status final do job: ${{ job.status }}"
